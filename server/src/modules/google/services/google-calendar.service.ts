import { Injectable, Logger } from '@nestjs/common';
import { google, calendar_v3 } from 'googleapis';
import { GoogleAuthService } from './google-auth.service';
import { Calendar } from '../../calendar/calendar';

@Injectable()
export class GoogleCalendarService {
    private readonly logger = new Logger(GoogleCalendarService.name);

    constructor(private readonly googleAuthService: GoogleAuthService) {}

    private async getCalendarClient(userId: string): Promise<calendar_v3.Calendar | null> {
        const accessToken = await this.googleAuthService.getValidAccessToken(userId);
        
        if (!accessToken) {
            this.logger.warn(`No valid access token for user ${userId}`);
            return null;
        }

        const oauth2Client = this.googleAuthService.getOAuth2Client();
        oauth2Client.setCredentials({ access_token: accessToken });

        return google.calendar({ version: 'v3', auth: oauth2Client });
    }

    async listCalendars(userId: string): Promise<Calendar[]> {
        try {
            const calendar = await this.getCalendarClient(userId);
            if (!calendar) {
                throw new Error('Not connected to Google Calendar');
            }

            const response = await calendar.calendarList.list();
            
            if (!response.data.items) {
                return [];
            }

            return response.data.items.map(item => ({
                id: '', // Will be generated by database
                user_id: userId,
                google_calendar_id: item.id || '',
                name: item.summary || undefined,
                description: item.description || undefined,
                timezone: item.timeZone || undefined,
                is_primary: item.primary || false,
                created_at: new Date(),
                updated_at: new Date()
            }));
        } catch (error) {
            this.logger.error(`Failed to list calendars for user ${userId}:`, error);
            throw new Error('Failed to fetch calendars from Google');
        }
    }

    async getCalendar(userId: string, calendarId: string): Promise<calendar_v3.Schema$Calendar | null> {
        try {
            const calendar = await this.getCalendarClient(userId);
            if (!calendar) {
                return null;
            }

            const response = await calendar.calendars.get({ calendarId });
            return response.data;
        } catch (error) {
            this.logger.error(`Failed to get calendar ${calendarId}:`, error);
            return null;
        }
    }

    async listEvents(
        userId: string,
        calendarId: string = 'primary',
        options?: {
            timeMin?: Date;
            timeMax?: Date;
            maxResults?: number;
        }
    ): Promise<calendar_v3.Schema$Event[]> {
        try {
            const calendar = await this.getCalendarClient(userId);
            if (!calendar) {
                throw new Error('Not connected to Google Calendar');
            }

            const response = await calendar.events.list({
                calendarId,
                timeMin: options?.timeMin?.toISOString(),
                timeMax: options?.timeMax?.toISOString(),
                maxResults: options?.maxResults || 100,
                singleEvents: true,
                orderBy: 'startTime'
            });

            return response.data.items || [];
        } catch (error) {
            this.logger.error(`Failed to list events for user ${userId}:`, error);
            throw new Error('Failed to fetch events from Google Calendar');
        }
    }

    async createEvent(
        userId: string,
        calendarId: string = 'primary',
        event: {
            summary: string;
            description?: string;
            start: Date;
            end: Date;
            location?: string;
        }
    ): Promise<calendar_v3.Schema$Event> {
        try {
            const calendar = await this.getCalendarClient(userId);
            if (!calendar) {
                throw new Error('Not connected to Google Calendar');
            }

            const response = await calendar.events.insert({
                calendarId,
                requestBody: {
                    summary: event.summary,
                    description: event.description,
                    location: event.location,
                    start: {
                        dateTime: event.start.toISOString(),
                        timeZone: 'UTC'
                    },
                    end: {
                        dateTime: event.end.toISOString(),
                        timeZone: 'UTC'
                    }
                }
            });

            this.logger.log(`Created event in Google Calendar for user ${userId}`);
            return response.data;
        } catch (error) {
            this.logger.error(`Failed to create event for user ${userId}:`, error);
            throw new Error('Failed to create event in Google Calendar');
        }
    }

    async updateEvent(
        userId: string,
        calendarId: string,
        eventId: string,
        event: {
            summary?: string;
            description?: string;
            start?: Date;
            end?: Date;
            location?: string;
        }
    ): Promise<calendar_v3.Schema$Event> {
        try {
            const calendar = await this.getCalendarClient(userId);
            if (!calendar) {
                throw new Error('Not connected to Google Calendar');
            }

            const updateData: calendar_v3.Schema$Event = {};
            
            if (event.summary) updateData.summary = event.summary;
            if (event.description) updateData.description = event.description;
            if (event.location) updateData.location = event.location;
            
            if (event.start) {
                updateData.start = {
                    dateTime: event.start.toISOString(),
                    timeZone: 'UTC'
                };
            }
            
            if (event.end) {
                updateData.end = {
                    dateTime: event.end.toISOString(),
                    timeZone: 'UTC'
                };
            }

            const response = await calendar.events.patch({
                calendarId,
                eventId,
                requestBody: updateData
            });

            this.logger.log(`Updated event ${eventId} in Google Calendar`);
            return response.data;
        } catch (error) {
            this.logger.error(`Failed to update event ${eventId}:`, error);
            throw new Error('Failed to update event in Google Calendar');
        }
    }

    async deleteEvent(
        userId: string,
        calendarId: string,
        eventId: string
    ): Promise<boolean> {
        try {
            const calendar = await this.getCalendarClient(userId);
            if (!calendar) {
                throw new Error('Not connected to Google Calendar');
            }

            await calendar.events.delete({
                calendarId,
                eventId
            });

            this.logger.log(`Deleted event ${eventId} from Google Calendar`);
            return true;
        } catch (error) {
            this.logger.error(`Failed to delete event ${eventId}:`, error);
            return false;
        }
    }

    async syncCalendars(userId: string): Promise<{ success: boolean; count: number }> {
        try {
            const calendars = await this.listCalendars(userId);
            
            this.logger.log(`Synced ${calendars.length} calendars for user ${userId}`);
            
            return {
                success: true,
                count: calendars.length
            };
        } catch (error) {
            this.logger.error(`Failed to sync calendars for user ${userId}:`, error);
            return {
                success: false,
                count: 0
            };
        }
    }
}
